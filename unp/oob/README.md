#带外数据(OOB－out of band)

###概念
带外数据是指连接双方中的一方发生重要事情，**想要迅速地通知对方**。（紧急性）    
这种通知在已经排队等待发送的任何“普通”(有时称为“带内”)数据之前发送。（高优先级发送）    
带外数据设计为比普通数据有**更高的优先级**。     
带外数据是**映射到现有的连接中**的，而不是在客户机和服务器间再用一个连接。（非独立性） 

#####详细解释
在字节流服务中，由于没有报文边界，用户进程在某一时刻可以读或写任意数量的字节。为保证传输正确或采用有流控制的协议时，都要进行缓存。但对某些特殊的需求，如交互式应用程序，又会要求取消这种缓存。   
在数据传送过程中，**希望不通过常规传输方式传送给用户以便及时处理的某一类信息**，如UNIX系统的中断键（Delete或Control-c）、终端流控制符（Control-s和Control-q），称为带外数据。    
逻辑上看，好象用户进程使用了一个独立的通道传输这些数据。该通道与每对连接的流相联系。由于Berkeley   Software   Distribution中对带外数据的实现与RFC   1122中规定的Host   Agreement   不一致,为了将互操作中的问题减到最小，应用程序编写者除非与现有服务互操作时要求带外数据外，最好不使用它。   
对带外数据的实现一般使用BSD的紧急数据指针方式，即TCP只保证将紧急数据之前的所有数据一起返回给应用程序，而应用程序怎样处理这个事件完全由自己决定，甚至可以认为是一般的数据而不加以特别对待，所以对于一些设计不太合理的程序，比如根本不判断read的返回值之类的，反而根本不会受到OOB的影响。 


#####发送带外数据的“概念性”
通常情况下，数据由连接的一端流到另一端，并且认为数据的所有字节都是精确排序的。**晚写入的字节绝不会早于先写入的字节到达**。然而套接口API概念性的提供了一些实用程序，从而可以使得一串数据无阻的先于通常的数据到达接收端。这就是所谓的**发送带外数据**。   
从技术上来说，一个TCP流不可以发送带外数据。而他所支持的只是一个概念性的紧急数据，这些紧急数据作为带外数据映射到套接口API。**TCP没有真正的带外数据，而是提供了一个我们要讨论的紧急模式(urgent mode)。**    
一个TCP流通常希望以完美的队列来发送数据字节，那么乱序的发送数据就似乎与流的概念相违背。那么**为什么要提供带外数据的套接口方法呢？**

一个流套接口会有一个大量的数据队列等待发送到网络。在远程端点，也会有大量已接收的，却还没有被 程序读取的数据。如果发送客户端程序由于一些原因需要取消已经写入服务器的请求，那么他就需要向服务器紧急发送一个标识取消的请求。如果向远程服务器发送取消请求失败，那么就会无谓的浪费服务器的资源。（**没有及时发送紧急数据导致负面后果**）
使用带外数据的实际程序例子就是telnet, rlogin, ftp命令。前两个程序会将中止字符作为紧急数据发送到远程端。这会允许远程端冲洗所有未处理 的输入，并且丢弃所有未发送的终端输出。这会快速中断一个向我们屏幕发送大量数据的运行进程。ftp命令使用带外数据来中断一个文件的传输。

#####实现上的变化
很不幸，TCP的实现在紧急数据（TCP协议没有真正的带外数据，而是在首部设置URG标志位表示带外数据）就如何处理上有两种不同的解释。这些区别我们将会本章的后面进行详细的讨论。这些不同的解释是：     

* TCP紧急指针的RFC793解释
* TCP紧急指针的BSD解释

现在已经出现了平分的状态，因为**原始的TCP规格允许两种解释**。从而，一个"主机需要"的RFC标识正确的解释。然而，大多数的实现都基于BSD源码，而在今天BSD方法还是一个通用的用法。从支持两种解释的角度而言，Linux处于分裂的状态。然而，Linux默认使用BSD解释。

Linux下查看当前的系统设置：
	
	$ cat /proc/sys/net/ipv4/tcp_stdurg
	0
	$
这里显示的输出为0。这表示当前为BSD解释。如果我们得到其他的输出结果(例如1)，那么如果我们希望得到也本章的例子相同的结果，我们应将其改为0。

下面列出了tcp_stdurg设置可能的取值。tcp_stdurg值可以在Shell脚本中进行查询和设置，包括启动与关闭脚本。

	/proc/sys/net/ipv4_stdurg的设置值：
	0   BSD解释(Linux默认)
	1   RFC793解释

如果我们需要将其设置改为0，我们需要root权限，然后输入下面的命令：
	
	# echo 0 > /proc/sys/net/ipv4/tcp_stdurg

进行双重检测总是很明知的，所以在改变以后再列出其值来确定改变是否为内核所接受。我们也可以在上面的例子中使用cat命令来显示0值。

###TCP带外数据

TCP协议只支持1字节带外数据，使用URG标志位和紧急指针指明带外数据：

* URG为带外数据标志位
* 紧急指针＝带外数据位置＋1
* 紧急指针的值在不同的实现中会有所不同（参考RFC 793 和RFC 1122）

TCP带外数据没有单独数据通道，带外数据包含在正常数据中发送。    
TCP套接口发送缓冲区中，要发送的数据依次排列。TCP将带外数据放置在套机口发送缓冲区的下一个可用位置，并设置这个连接的TCP紧急指针(urgent pointer)为下一个可用位置。并且标记带外字节为“OOB”。 


#####发送带外数据API
write()调用将会写入一个我们已习惯的带内数据。相应的，必须使用一个新的函数来写入带外数据。为了这个目的，在这里列出send()函数原型：

	#include <sys/types.h>
	#include <sys/socket.h>
	int send(int sockfd, const void *msg, int len, unsigned int flags);

这个函数需要四个参数，分别为：

1. 要写入的套接口sockfd
2. 存放要写入的消息的缓冲地址msg
3. 消息长度(len)
4. 发送选项flags

send函数与write函数相类似，所不同的只是提供了额外的sflags参数。这是实际的部分。send函数返回写入的字节数，如果发生错误则会返回-1，检测errno可以得到错误原因。    
要发送带外数据，与write调用相似，使用前三个参数。如果我们为flags参数指定了C语言**宏MSG_OOB**，则数据是作为带外数据发送的，而不是通常的带内数据，如下面的例子代码：

	char buf[64]; /* Data */
	int len;      /* Bytes */
	int sockfd;   /* Socket */
	...
	send(sockfd, buf, len, MSG_OOB);
	//send(sockfd, 'a', 1, MSG_OOB);

如果所提供的flags参数没有MSG_OOB位，那么数据是作为通常数据写入的。这就允许我们使用同一个函数同时发送带内数据与带外数据。我们只需要简单的在程序控制中改变flags参数值来达到这个目的。



如果我们发送多字节的带外数据又会如何呢，就像：
	
	send(fd, "abc", 3, MSG_OOB);
在这个例子中，TCP的紧急指针指向最后那个字节后面，也就是说最后那个字节(字母c)被认为是带外字节。发送多个字节，只有最后一个字节被认为是带外数据。

#####读取带外数据API

带外数据可以用两种不同的方法进行读取：

* 单独读取带外数据
* 与带内数据混合读取

为了与通常数据流分开单独读取带外数据，我们需要使用recv函数。recv函数与read函数相似，只是有一个额外的flags参数。这个函数的原型如下：

	#include <sys/types.h>
	#include <sys/socket.h>
	int recv(int sockfd, void *buf, int len, unsigned int flags);

recv函数接受四参数，分别为：

1. 要从中接收数据的套接口sockfd
2. 要放置所接收的数据的缓冲区地址buf
3. 接收缓冲区的最大长度
4. 调用所需的flags参数

正如我们所看到的，recv函数是与send函数调用相对应的函数。为要接收带外数据，在flags参数中指定C宏MSG_OOB。没有MSG_OOB标志位，recv函数所接收的为通常的带内数据，就像通常的read调用一样。

recv函数返回所接收到的字节数，如果出错则返回-1，检测errno可以得到错误原因。

下面的代码例子演示了如何读取带外数据：

	char buf[128];   /* Buffer */
	int n;      /* No. of bytes */
	int sockfd;             /* Socket */
	int len;         /* Max bytes */
	...
	n = recv(sockfd,buf,len,MSG_OOB);

#####SIGURG信号

当带外数据到达时，接收进程需要收到通知。如果需要与通常数据流分开读取时更是如此。这样做的一个方法就是当带外数据到达时，使Linux内核向我们的进程发送一个SIGURG信号。

使用SIGURG信号通知需要两个先决条件：

* 必须拥有套接口
* 必须为SIGURG创建一个信号处理器

要接收SIGURG信号，接收进程必须为套接口的所有者。要建立这样的拥有关系，可以使用fcntl函数。其函数原型如下：

	#include <unistd.h>	
	#include <fcntl.h>
	int fcntl(int fd, int cmd, long arg);

函数参数如下：

1. 要在其上执行控制函数的文件描述符fd(或是套接口，套接口本质上属文件描述符)
2. 要执行的控制函数cmd
3. 要设置的值arg

函数的返回值依赖于fcntl所执行的控制函数。对于课外阅读感兴趣的读者，fcntl的Linux man手册页详细的描述了cmd的F_SETOWN操作。

要将我们的进程创建为套接口的所有者，接收程序需要使用下面的代码：

	int z; /* Status */
	int s; /* Socket */
	z = fcntl(s, F_SETOWN, getpid());
	if ( z == -1 ) {
		perror("fcntl(2)");
		exit(1);
	}
	
F_SETOWN操作会使得fcntl函数成功时返回0，失败时返回-1。


下面从接收者的角度看一下：

1. 当TCP收到了一个设置URG标志的分节时，紧急指针被检查，看它是否指向新的带外数据。也就是说，这是否首次在从发送者到接收者的数据流中TCP的紧急模式指向这个特殊字节。发送者TCP发送多个包含URG标志，但紧急指针却指向相同数据字节的分节，这种情况相当普遍。这些分节中只有第一个导致接收进程被通知有新带外数据到达。

2. 当新紧急指针到达时，接收进程被通知。首先，SIGURG信号发送给套接口属主，这里假设已调用fcntl和ioctl给套接口建立了属主，还假设属主进程已经为这个信号建立了信号处理程序。其次，如果进程阻塞在select调用中，等待这个套机口描述字有一个异常条件，那么select返回。当一个新紧急指针到达时，这两个对接收进程可能的通知就会发生，而不管是由紧急指针指向的实际数据字节已经到达接收者TCP

3. 当由紧急指针指向的实际数据字节到达接收者TCP时，这个数据字节可以被拉出带外或继续在线存放。SO_OOBINLINE套接口选项缺省时是不设置的，所以这个数据字节并不放入套接口接收缓冲区。相反，这个数据字节被放到这个连接的单独的1字节带外缓冲区。进程从这个特别的1字节缓冲区中读出的仅有方法是调用recv, recvfrom或者recvmsg并指定MSG_OOB标志。 然而不过进程设置了SO_OOBINLINE套接口选项，那么由TCP的紧急指针指向的单字节数据将被留在通常的套接口接收缓冲区里。在这种情况下，进程不能指定MSG_OOB标志去读带外数据字节。这个进程通过检查本连接的带外标志(out-of-band mark)来获悉何时它到达了这个数据字节。
