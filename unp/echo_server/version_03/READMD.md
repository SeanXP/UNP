实现最简单的echo server.

其中在echo_server中没有处理子进程, 因此会导致僵死状态的子进程：
客户端连接时，服务器会创建子进程负责处理客户端，
当客户端关闭后，子进程结束(向父进程发送SIGCHLD信号, 等待父进程处理; 子进程进入僵死状态, 
维护部分子进程的信息, 以便父进程以后某个时间获取。)

然而此版本的echo server, 会导致很多的僵死子进程，这样占用了过多内核的空间。
在第2版本的echo server中将解决这个问题.

--------------------

第2版本使用signal配置了SIGCHLD的信号处理函数, 并在函数中, 使用wait()等待刚才发送SIGCHLD信号的子进程。
可以测试，版本2解决了僵死子进程的问题。

但是！

由于wait()只执行一次，如果同时有多个子进程结束，同时想服务器发送SIGCHLD信号，则信号处理函数只执行一次，
这样又将导致多个僵死子进程的产生。

解决方案：使用while循环内嵌套waitpid()函数。其中waitpid()函数使用选项WNOHANG实现非阻塞。
